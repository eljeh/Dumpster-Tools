---
import zones from '../data/zones.json';
import settingZones from '../data/settingZones.json';
import MapControls from './MapControls.astro';

// Find the min and max coordinates to set up the viewport
let minX = Infinity;
let maxX = -Infinity;
let minY = Infinity;
let maxY = -Infinity;

Object.entries(zones).forEach(([_, zoneArray]) => {
	zoneArray.forEach((zone) => {
		if (!zone.TopLeft || !zone.BottomRight) return;
		const topLeft = {
			x: parseFloat(zone.TopLeft.split(' ')[0].replace('X=', '')),
			y: parseFloat(zone.TopLeft.split(' ')[1].replace('Y=', '')),
		};
		const bottomRight = {
			x: parseFloat(zone.BottomRight.split(' ')[0].replace('X=', '')),
			y: parseFloat(zone.BottomRight.split(' ')[1].replace('Y=', '')),
		};
		minX = Math.min(minX, topLeft.x, bottomRight.x);
		maxX = Math.max(maxX, topLeft.x, bottomRight.x);
		minY = Math.min(minY, topLeft.y, bottomRight.y);
		maxY = Math.max(maxY, topLeft.y, bottomRight.y);
	});
});

// Add some padding
const padding = (maxX - minX) * 0.05;
minX -= padding;
maxX += padding;
minY -= padding;
maxY += padding;

// Function to convert game coordinates to SVG coordinates
const toSvgX = (x: number) => ((x - minX) / (maxX - minX)) * 1000;
const toSvgY = (y: number) => 1000 - ((y - minY) / (maxY - minY)) * 1000; // Flip Y axis

const ZONE_NAME_MAPPINGS = {
	Sector_: (name: string) => name.replace('Sector_', ''),
	POI_PVP_: (name: string) => name.replace('POI_PVP_', 'PvP '),
	POI_PVE_: (name: string) => name.replace('POI_PVE_', 'PvE '),
	POI_custom_: (name: string) => name.replace('POI_custom_', ''),
	Bunkers_PVP: (name: string) => name.replace('Bunkers_PVP', 'PvP Bunker'),
	Bunkers_PVE: (name: string) => name.replace('Bunkers_PVE', 'PvE Bunker'),
	Outpost_: (name: string) => `${name.replace('Outpost_', '')} Outpost`,
	WarZoneDrops: (name: string) => name.replace('WarZoneDrops', 'Warzone Drops'),
} as const;

const formatZoneName = (zoneName: string): string => {
	const prefix = Object.keys(ZONE_NAME_MAPPINGS).find((key) =>
		zoneName.startsWith(key),
	);
	return prefix ? ZONE_NAME_MAPPINGS[prefix](zoneName) : zoneName;
};
---

<MapControls />

<div
	class='map-container'
	data-min-x={minX}
	data-max-x={maxX}
	data-min-y={minY}
	data-max-y={maxY}
>
	<svg viewBox='210 30 930 930' class='map'>
		<image
			href='../assets/images/map.webp'
			width='1000'
			height='1000'
			x='170'
			y='0'
		/>
		{
			Object.entries(zones).map(([zoneName, zoneArray]) =>
				zoneArray.map((zone) => {
					if (!zone.TopLeft || !zone.BottomRight) return null;

					const topLeft = {
						x: parseFloat(zone.TopLeft.split(' ')[0].replace('X=', '')),
						y: parseFloat(zone.TopLeft.split(' ')[1].replace('Y=', '')),
					};

					const bottomRight = {
						x: parseFloat(zone.BottomRight.split(' ')[0].replace('X=', '')),
						y: parseFloat(zone.BottomRight.split(' ')[1].replace('Y=', '')),
					};

					const width = Math.abs(toSvgX(topLeft.x) - toSvgX(bottomRight.x));
					const height = Math.abs(toSvgY(topLeft.y) - toSvgY(bottomRight.y));

					// flip left to right all the coordinates
					topLeft.x = -topLeft.x;
					bottomRight.x = -bottomRight.x;

					// if zoneName starts with Sector_, add zone-Sector_ to the class
					const sector = formatZoneName(zoneName);

					return (
						<g
							class={`zone-${zoneName}`}
							style={
								zoneName.includes('Sector_')
									? 'display: block;'
									: 'display: none;'
							}>
							<title>
								{`${sector}\nTop Left: (${topLeft.x.toFixed(2)}, ${topLeft.y.toFixed(2)})\nBottom Right: (${bottomRight.x.toFixed(2)}, ${bottomRight.y.toFixed(2)})`}
							</title>
							<rect
								x={toSvgX(Math.min(topLeft.x, bottomRight.x))}
								y={toSvgY(Math.max(topLeft.y, bottomRight.y))}
								width={width}
								height={height}
								class='zone-rect'
							/>
							<text
								x={toSvgX(Math.min(topLeft.x, bottomRight.x)) + width / 2}
								y={toSvgY(Math.max(topLeft.y, bottomRight.y)) + height / 2}
								class='zone-label'>
								{sector}
							</text>
						</g>
					);
				}),
			)
		}
		{
			Object.entries(settingZones).map(([zoneName, zoneArray]) =>
				zoneArray.map((zone) => {
					if (!zone.Center) return null;

					const center = {
						x: -parseFloat(zone.Center.split(' ')[0]), // Flip X coordinate
						y: parseFloat(zone.Center.split(' ')[1]),
					};

					// Handle both circular and rectangular zones
					const isCircular = zone.Radius !== undefined;
					let width, height, radius;

					if (isCircular) {
						radius = parseFloat(zone.Radius) * 100000;
					} else if (zone.size) {
						const [sizeX, sizeY] = zone.size
							.split(' ')
							.map((s) => parseFloat(s) * 100000);
						width = sizeX;
						height = sizeY;
					} else {
						return null;
					}

					// if zoneName starts with Sector_, add zone-Sector_ to the class
					const sector = formatZoneName(zoneName);

					return (
						<g
							class={`zone-${zoneName}`}
							style={
								zoneName.includes('Sector_')
									? 'display: block;'
									: 'display: none;'
							}>
							<title>
								{isCircular
									? `${sector}\nCenter: (${center.x.toFixed(2)}, ${center.y.toFixed(2)})\nRadius: ${zone.Radius}`
									: `${sector}\nCenter: (${center.x.toFixed(2)}, ${center.y.toFixed(2)})\nSize: ${zone.size}`}
							</title>

							{isCircular ? (
								<circle
									cx={toSvgX(center.x)}
									cy={toSvgY(center.y)}
									r={(radius / (maxX - minX)) * 1000}
									class='zone-circ'
								/>
							) : (
								<rect
									x={toSvgX(center.x - width)}
									y={toSvgY(center.y + height)}
									width={(width / (maxX - minX)) * 2000}
									height={(height / (maxY - minY)) * 2000}
									class='zone-rect'
								/>
							)}
							<text
								x={toSvgX(center.x)}
								y={toSvgY(center.y)}
								class='zone-label'>
								{sector
									.replace('PvP', '')
									.replace('PvE', '')
									.replace('PVP_', '')
									.replace('PVE_', '')}
							</text>
						</g>
					);
				}),
			)
		}
	</svg>
</div>

<script>
	import { PUBLIC_WBAUTH, PUBLIC_WBBOTID, PUBLIC_ROOT } from 'astro:env/client';
	const WBAuth = PUBLIC_WBAUTH;
	const WBBotID = PUBLIC_WBBOTID;
	const Root = PUBLIC_ROOT;

	document.addEventListener('astro:page-load', () => {
		const mapContainer = document.querySelector('.map-container');
		const minX = parseFloat(mapContainer.dataset.minX);
		const maxX = parseFloat(mapContainer.dataset.maxX);
		const minY = parseFloat(mapContainer.dataset.minY);
		const maxY = parseFloat(mapContainer.dataset.maxY);

		const toSvgX = (x) => ((x - minX) / (maxX - minX)) * 1000;
		const toSvgY = (y) => 1000 - ((y - minY) / (maxY - minY)) * 1000;

		function displayPlayerLocations() {
			const url = `https://api.whalleybot.com/bot/${WBBotID}/PlayerLocations`;
			fetch(url, {
				method: 'GET',
				headers: {
					Accept: '*/*',
					Authorization: WBAuth,
				},
			})
				.then((response) => {
					if (!response.ok) {
						throw new Error('Network response was not ok');
					}
					return response.json();
				})
				.then((data) => {
					// Remove existing player markers container
					document.querySelector('.player-markers-container')?.remove();

					// Create container for all player markers
					const svg = document.querySelector('.map');
					const container = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'g',
					);
					container.classList.add('player-markers-container');
					container.style.display = document.getElementById('players-toggle')
						.checked
						? 'block'
						: 'none';

					// Add new player markers
					data.forEach((player) => {
						const [x, y] = player.lastKnownLocation.split(' ');
						const playerX = -parseFloat(x); // Flip X coordinate like we do for zones
						const playerY = parseFloat(y);

						const g = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'g',
						);
						g.classList.add('player-marker');

						// Add title element for tooltip
						const title = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'title',
						);
						title.textContent = `
						Player: ${player.playerName}\nID: ${player.steamID}\ntype: ${player.type}\nLocation: (${playerX.toFixed(2)}, ${playerY.toFixed(2)})`;
						g.appendChild(title);

						// Create circle for player
						const circle = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'circle',
						);
						circle.setAttribute('cx', toSvgX(playerX));
						circle.setAttribute('cy', toSvgY(playerY));
						circle.setAttribute('r', '3');

						// Create text label
						const text = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'text',
						);
						text.setAttribute('x', toSvgX(playerX));
						text.setAttribute('y', toSvgY(playerY) - 5);
						text.textContent = player.playerName;

						g.appendChild(circle);
						g.appendChild(text);
						container.appendChild(g);
					});

					svg.appendChild(container);
				})
				.catch((error) => {
					console.error('Error fetching player locations:', error);
				});
		}

		function displayVehicleLocations() {
			const url = `https://api.whalleybot.com/bot/${WBBotID}/VehicleLocations`;
			fetch(url, {
				method: 'GET',
				headers: {
					Accept: '*/*',
					Authorization: WBAuth,
				},
			})
				.then((response) => {
					if (!response.ok) {
						console.error(
							'API response not ok:',
							response.status,
							response.statusText,
						);
						throw new Error('Network response was not ok');
					}
					return response.json();
				})
				.then((data) => {
					// Remove existing vehicle markers container
					const existingContainer = document.querySelector(
						'.vehicle-markers-container',
					);
					if (existingContainer) {
						existingContainer.remove();
					}

					// Create container for all vehicle markers
					const svg = document.querySelector('.map');
					const container = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'g',
					);
					container.classList.add('vehicle-markers-container');
					container.style.display = document.getElementById('vehicles-toggle')
						.checked
						? 'block'
						: 'none';

					// Add new vehicle markers
					let validVehicles = 0;
					let skippedVehicles = 0;

					data.forEach((vehicle) => {
						// Skip if vehicle has no location
						if (!vehicle.value.coords) {
							skippedVehicles++;
							return;
						}

						const [x, y, z] = vehicle.value.coords.split(' ');
						// Skip if we can't parse coordinates
						if (!x || !y) {
							skippedVehicles++;
							return;
						}

						const vehicleX = -parseFloat(x);
						const vehicleY = parseFloat(y);

						// Skip if coordinates are invalid
						if (isNaN(vehicleX) || isNaN(vehicleY)) {
							skippedVehicles++;
							return;
						}

						validVehicles++;

						const vehicleType = vehicle.value.type
							.trim()
							.replace('BPC_', '')
							.replace('BP_', '');

						const g = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'g',
						);
						g.classList.add('vehicle-marker');
						g.classList.add(`${vehicleType}`);
						// if vehicle.value.reg is not null, add vehicle-reg to the class
						if (!vehicle.value.reg) {
							g.classList.add(`not-registered`);
						} else {
							g.classList.add(`registered`);
						}

						// Add title element for tooltip
						const title = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'title',
						);
						title.textContent = `Vehicle: ${vehicle.value.type.trim()}\nLocation: (${vehicleX.toFixed(2)}, ${vehicleY.toFixed(2)})\nRegistration: ${vehicle.value.reg}`;
						g.appendChild(title);

						// Create vehicle icon (using a circle instead of triangle for simplicity)
						const circle = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'circle',
						);
						circle.setAttribute('cx', toSvgX(vehicleX));
						circle.setAttribute('cy', toSvgY(vehicleY));
						circle.setAttribute('r', '3');
						circle.classList.add('vehicle-icon');

						// Create text label
						const text = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'text',
						);
						text.setAttribute('x', toSvgX(vehicleX));
						text.setAttribute('y', toSvgY(vehicleY) - 5);
						text.textContent = vehicleType.replace('_', ' ');

						g.appendChild(circle);
						g.appendChild(text);
						container.appendChild(g);
					});

					svg.appendChild(container);
				})
				.catch((error) => {
					console.error('Error fetching vehicle locations:', error);
				});
		}

		// Update player and vehicle locations every 5 minutes
		displayCurrentEvents();
		displayPlayerLocations();
		displayVehicleLocations();
		displayKillPositions();
		displayFlagLocations();
		setInterval(() => {
			displayCurrentEvents();
			displayPlayerLocations();
			displayVehicleLocations();
			displayKillPositions();
			displayFlagLocations();
		}, 300000);

		// Get all toggle checkboxes
		const sectorsToggle = document.getElementById('sectors-toggle');
		const playersToggle = document.getElementById('players-toggle');
		const vehicleToggle = document.getElementById('vehicles-toggle');
		const registeredVehiclesToggle = document.getElementById(
			'registered-vehicles-toggle',
		);
		const notRegisteredVehiclesToggle = document.getElementById(
			'not-registered-vehicles-toggle',
		);
		const flagsToggle = document.getElementById('flags-toggle');
		const eventsToggle = document.getElementById('events-toggle');
		const killsToggle = document.getElementById('kills-toggle');
		const ragerToggle = document.getElementById('rager-toggle');
		const wolfswagenToggle = document.getElementById('wolfswagen-toggle');
		const laikaToggle = document.getElementById('laika-toggle');
		const kingletdusterToggle = document.getElementById('kingletduster-toggle');
		const barbaToggle = document.getElementById('barba-toggle');
		const risToggle = document.getElementById('ris-toggle');
		const dirtbikeToggle = document.getElementById('dirtbike-toggle');
		const cruiserToggle = document.getElementById('cruiser-toggle');
		const bicyclesToggle = document.getElementById('bicycles-toggle');
		const wheelbarrowToggle = document.getElementById('wheelbarrow-toggle');

		const pvpToggle = document.getElementById('pvp-toggle');
		const pveToggle = document.getElementById('pve-toggle');
		const pveBunkerToggle = document.getElementById('pve-bunker-toggle');
		const pvpBunkerToggle = document.getElementById('pvp-bunker-toggle');
		const warzonesToggle = document.getElementById('warzones-toggle');
		const outpostsToggle = document.getElementById('outposts-toggle');
		const poisToggle = document.getElementById('pois-toggle');
		const bunkersToggle = document.getElementById('bunkers-toggle');
		const imageToggle = document.getElementById('image-toggle');
		const customPOIToggle = document.getElementById('custom-pois-toggle');

		// Function to toggle visibility
		function updateVisibility(toggleElement, selector) {
			if (!toggleElement) return;

			const updateElements = () => {
				const elements = document.querySelectorAll(selector);
				elements.forEach((element) => {
					// Special handling for vehicle markers container
					if (selector === '.vehicle-markers-container') {
						element.style.display = toggleElement.checked ? 'block' : 'none';
						return;
					}

					// For individual vehicle markers, check both the vehicles toggle and registration toggles
					if (selector.includes('.vehicle-marker')) {
						const isVehiclesEnabled = vehicleToggle.checked;
						const isRegistered = element.classList.contains('registered');
						const isRegisteredEnabled = registeredVehiclesToggle.checked;
						const isNotRegisteredEnabled = notRegisteredVehiclesToggle.checked;

						const shouldShow =
							isVehiclesEnabled &&
							((isRegistered && isRegisteredEnabled) ||
								(!isRegistered && isNotRegisteredEnabled));

						element.style.display = shouldShow ? 'block' : 'none';
					} else {
						element.style.display = toggleElement.checked ? 'block' : 'none';
					}
				});
			};

			toggleElement.addEventListener('change', updateElements);
			// Also update initial state
			updateElements();

			// For vehicle-specific toggles, also listen to vehicles toggle changes
			if (selector.includes('.vehicle-marker')) {
				vehicleToggle.addEventListener('change', updateElements);
				if (toggleElement !== registeredVehiclesToggle) {
					registeredVehiclesToggle.addEventListener('change', updateElements);
				}
				if (toggleElement !== notRegisteredVehiclesToggle) {
					notRegisteredVehiclesToggle.addEventListener(
						'change',
						updateElements,
					);
				}
			}
		}

		function displayCurrentEvents() {
			const url = `https://api.whalleybot.com/bot/${WBBotID}/WorldEvent/GetCurrentEvent`;
			fetch(url, {
				method: 'GET',
				headers: {
					Accept: '*/*',
					Authorization: WBAuth,
				},
			})
				.then((response) => {
					if (!response.ok) {
						console.error(
							'API response not ok:',
							response.status,
							response.statusText,
						);
						throw new Error('Network response was not ok');
					}
					return response.json();
				})
				.then((data) => {
					// Remove existing event markers container
					document.querySelector('.event-markers-container')?.remove();

					if (!data || !data.currentZonePos) return;

					// Create container for event marker
					const svg = document.querySelector('.map');
					const container = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'g',
					);
					container.classList.add('event-markers-container');

					const [x, y, z] = data.currentZonePos.split(' ');
					const eventX = -parseFloat(x); // Flip X coordinate like we do for zones
					const eventY = parseFloat(y);

					const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
					g.classList.add('event-marker');

					// Add title element for tooltip
					const title = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'title',
					);
					title.textContent = `Event: ${data.currentZone}\nLocation: (${eventX.toFixed(2)}, ${eventY.toFixed(2)})`;
					g.appendChild(title);

					// Create circle for event zone (radius of 100 units)
					const circle = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'circle',
					);
					circle.setAttribute('cx', toSvgX(eventX));
					circle.setAttribute('cy', toSvgY(eventY));
					circle.setAttribute('r', '50'); // Adjust this value to change zone size
					circle.classList.add('event-zone');

					// Create text label
					const text = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'text',
					);
					text.setAttribute('x', toSvgX(eventX));
					text.setAttribute('y', toSvgY(eventY));
					text.classList.add('event-label');
					text.textContent = data.currentZone;

					g.appendChild(circle);
					g.appendChild(text);
					container.appendChild(g);
					svg.appendChild(container);
				})
				.catch((error) => {
					console.error('Error fetching current events:', error);
				});
		}

		function displayKillPositions() {
			const url = `https://api.whalleybot.com/bot/${WBBotID}/GetKillLogs`;
			fetch(url, {
				method: 'GET',
				headers: {
					Accept: '*/*',
					Authorization: WBAuth,
				},
			})
				.then((response) => {
					if (!response.ok) {
						throw new Error('Network response was not ok');
					}
					return response.json();
				})
				.then((data) => {
					// Remove existing kill markers container
					document.querySelector('.kill-markers-container')?.remove();

					// Create container for kill markers
					const svg = document.querySelector('.map');
					const container = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'g',
					);
					container.classList.add('kill-markers-container');

					Object.keys(data).forEach((key) => {
						if (key.includes('Comitted suicide')) {
							// Handle suicide
							const locationMatch = key.match(
								/X=(-?\d+\.?\d*) Y=(-?\d+\.?\d*)/,
							);
							if (locationMatch) {
								const x = -parseFloat(locationMatch[1]); // Flip X coordinate
								const y = parseFloat(locationMatch[2]);
								const username = key.match(/User: ([^\s(]+)/)?.[1] || 'Unknown';

								addKillMarker(container, x, y, 'suicide', username);
							}
						} else if (key.includes('Killer')) {
							// Handle kill
							try {
								const killData = JSON.parse(key.substring(key.indexOf('{')));
								const killerX = -killData.Killer.ServerLocation.X; // Flip X coordinate
								const killerY = killData.Killer.ServerLocation.Y;
								const victimX = -killData.Victim.ServerLocation.X; // Flip X coordinate
								const victimY = killData.Victim.ServerLocation.Y;

								// Add killer marker
								addKillMarker(
									container,
									killerX,
									killerY,
									'killer',
									killData.Killer.ProfileName,
									{
										victim: killData.Victim.ProfileName,
										weapon: killData.Weapon,
										time: killData.TimeOfDay,
									},
								);

								// Add victim marker
								addKillMarker(
									container,
									victimX,
									victimY,
									'victim',
									killData.Victim.ProfileName,
								);

								// Add line connecting killer and victim
								const line = document.createElementNS(
									'http://www.w3.org/2000/svg',
									'line',
								);
								line.setAttribute('x1', toSvgX(killerX));
								line.setAttribute('y1', toSvgY(killerY));
								line.setAttribute('x2', toSvgX(victimX));
								line.setAttribute('y2', toSvgY(victimY));
								line.classList.add('kill-line');
								container.appendChild(line);
							} catch (e) {
								console.error('Error parsing kill data:', e);
							}
						}
					});

					svg.appendChild(container);
				})
				.catch((error) => {
					console.error('Error fetching kill positions:', error);
				});
		}

		function addKillMarker(container, x, y, type, username, details = null) {
			const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			g.classList.add('kill-marker', type);

			// Add title element for tooltip
			const title = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'title',
			);
			if (type === 'killer') {
				title.textContent = `Killer: ${username}\nVictim: ${details.victim}\nWeapon: ${details.weapon}\nTime: ${details.time}`;
			} else if (type === 'victim') {
				title.textContent = `Victim: ${username}`;
			} else {
				title.textContent = `Suicide: ${username}`;
			}
			g.appendChild(title);

			// Create marker symbol
			const marker = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'circle',
			);
			marker.setAttribute('cx', toSvgX(x));
			marker.setAttribute('cy', toSvgY(y));
			marker.setAttribute('r', '1');
			marker.classList.add('kill-icon');
			g.appendChild(marker);

			// Create text label
			const text = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'text',
			);
			text.setAttribute('x', toSvgX(x));
			text.setAttribute('y', toSvgY(y) - 5);
			text.textContent = username;
			g.appendChild(text);

			container.appendChild(g);
		}

		function displayFlagLocations() {
			const url = `https://api.whalleybot.com/bot/${WBBotID}/FlagLocations`;
			fetch(url, {
				method: 'GET',
				headers: {
					Accept: '*/*',
					Authorization: WBAuth,
				},
			})
				.then((response) => {
					if (!response.ok) {
						throw new Error('Network response was not ok');
					}
					return response.json();
				})
				.then((data) => {
					// Remove existing flag markers container
					document.querySelector('.flag-markers-container')?.remove();

					// Create container for flag markers
					const svg = document.querySelector('.map');
					const container = document.createElementNS(
						'http://www.w3.org/2000/svg',
						'g',
					);
					container.classList.add('flag-markers-container');

					// Convert object to array if necessary
					const flagsArray = Array.isArray(data) ? data : Object.values(data);

					flagsArray.forEach((flag) => {
						if (!flag.location) return; // Skip if no location data

						const [x, y, z] = flag.location.split(' ');
						const flagX = -parseFloat(x); // Flip X coordinate like we do for zones
						const flagY = parseFloat(y);

						const g = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'g',
						);
						g.classList.add('flag-marker');

						// Add title element for tooltip
						const title = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'title',
						);
						title.textContent = `Flag ID: ${flag.id}\nOwner: ${flag.ownerName}\nSteam ID: ${flag.ownerID}\nLocation: (${flagX.toFixed(2)}, ${flagY.toFixed(2)})`;
						g.appendChild(title);

						// Create flag icon (using a custom path for a flag shape)
						const flagIcon = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'path',
						);
						// New flag design: pole with waving flag
						const flagPath = `
							M ${toSvgX(flagX)},${toSvgY(flagY)} 
							l 0,-6 
							m 0,0 
							l 8,-6 
							l -8,0 
							l 0,10
						`;
						flagIcon.setAttribute('d', flagPath);
						flagIcon.classList.add('flag-icon');
						g.appendChild(flagIcon);

						// Create text label
						const text = document.createElementNS(
							'http://www.w3.org/2000/svg',
							'text',
						);
						text.setAttribute('x', toSvgX(flagX));
						text.setAttribute('y', toSvgY(flagY) - 15);
						text.textContent = flag.ownerName;
						g.appendChild(text);

						container.appendChild(g);
					});

					svg.appendChild(container);
				})
				.catch((error) => {
					console.error('Error fetching flag locations:', error);
				});
		}

		// Set up toggle handlers
		updateVisibility(sectorsToggle, '[class^="zone-Sector_"]');
		updateVisibility(playersToggle, '.player-markers-container');
		updateVisibility(flagsToggle, '.flag-markers-container');
		updateVisibility(eventsToggle, '.event-markers-container');
		updateVisibility(killsToggle, '.kill-markers-container');
		// updateVisibility(vehicleToggle, '.vehicle-markers-container');
		updateVisibility(ragerToggle, '.Rager');
		updateVisibility(wolfswagenToggle, '.WolfsWagen');
		updateVisibility(laikaToggle, '.Laika');
		updateVisibility(kingletdusterToggle, '.Kinglet_Duster');
		updateVisibility(barbaToggle, '.Barba, .BigRaft, .SmallRaft, .SUP');
		updateVisibility(risToggle, '.RIS');
		updateVisibility(dirtbikeToggle, '.Dirtbike');
		updateVisibility(cruiserToggle, '.Cruiser');
		updateVisibility(bicyclesToggle, '.MountainBike, .CityBike');
		updateVisibility(
			wheelbarrowToggle,
			'.WheelBarrow_Improvised, .WheelBarrow_Metal',
		);
		updateVisibility(pvpToggle, '.zone-PVP');
		updateVisibility(pveToggle, '.zone-PVE');
		updateVisibility(
			bunkersToggle,
			'[class^="zone-PVP_Bunker"], [class^="zone-PVE_Bunker"]',
		);
		updateVisibility(pveBunkerToggle, '[class^="zone-Bunkers_PVE"]');
		updateVisibility(pvpBunkerToggle, '[class^="zone-Bunkers_PVP"]');
		updateVisibility(warzonesToggle, '.zone-WarZoneDrops');
		updateVisibility(outpostsToggle, '[class^="zone-Outpost_"]');
		updateVisibility(
			poisToggle,
			'[class^="zone-POI_PVP"], [class^="zone-POI_PVE"]',
		);
		updateVisibility(customPOIToggle, '[class^="zone-POI_custom"]');
		updateVisibility(imageToggle, '.map image');

		// Update the vehicle toggle handlers
		updateVisibility(vehicleToggle, '.vehicle-markers-container');
		updateVisibility(registeredVehiclesToggle, '.vehicle-marker.registered');
		updateVisibility(
			notRegisteredVehiclesToggle,
			'.vehicle-marker.not-registered',
		);

		// Add zoom functionality
		const svg = document.querySelector('.map');
		let isZoomed = false;
		let currentZoom = null;
		const defaultViewBox = '210 30 930 930';
		const imageWidth = 930;
		const imageHeight = 930;
		const imageX = 210;
		const imageY = 30;

		// Function to handle zoom
		function zoomToElement(element) {
			if (!svg || !element) return;

			const rect = element.querySelector('.zone-rect');
			if (!rect) return;

			const bbox = rect.getBBox();
			const padding = 20;

			const viewBox = {
				x: bbox.x - padding,
				y: bbox.y - padding,
				width: bbox.width + padding * 2,
				height: bbox.height + padding * 2,
			};

			if (isZoomed && currentZoom === element) {
				svg.setAttribute('viewBox', defaultViewBox);
				isZoomed = false;
				currentZoom = null;
			} else {
				svg.setAttribute(
					'viewBox',
					`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`,
				);
				isZoomed = true;
				currentZoom = element;
			}
		}

		// Add click handlers to sector zones
		document.querySelectorAll('[class^="zone-Sector_"]').forEach((zone) => {
			zone.style.cursor = 'pointer';
			zone.addEventListener('click', () => zoomToElement(zone));
		});

		// Add reset zoom on map container double click
		mapContainer.addEventListener('dblclick', (e) => {
			if (e.target === mapContainer || e.target === svg) {
				svg.setAttribute('viewBox', defaultViewBox);
				isZoomed = false;
				currentZoom = null;
			}
		});
	});
</script>

<style is:inline>
	:root {
		/* Base colors */
		--color-white: hsl(0, 0%, 100%);
		--color-white-40: hsla(0, 0%, 100%, 0.4);
		--color-white-10: hsla(0, 0%, 100%, 0.1);

		/* Zone colors */
		--color-zone-default: hsl(207, 44%, 49%);
		--color-zone-default-fill: hsla(207, 44%, 49%, 0.02);
		--color-zone-default-hover: hsla(207, 44%, 49%, 0.4);

		/* PvE colors */
		--color-pve: hsl(121, 100%, 75%);
		--color-pve-fill: hsla(121, 100%, 75%, 0.009);
		--color-pve-hover: hsla(121, 100%, 50%, 0.04);

		/* PvP colors */
		--color-pvp: hsla(0, 44%, 49%, 0.75);
		--color-pvp-fill: hsla(0, 44%, 49%, 0.5);

		/* Special zone colors */
		--color-warzone: hsla(297, 44%, 49%, 0.75);
		--color-warzone-fill: hsla(297, 44%, 49%, 0.5);

		--color-community: hsla(308, 100%, 50%, 0.75);
		--color-community-fill: hsla(308, 100%, 50%, 0.5);

		/* POI and Outpost colors */
		--color-custom-poi: hsla(147, 41%, 41%, 0.75);
		--color-custom-poi-fill: hsla(147, 41%, 41%, 0.5);

		--color-pve-poi: hsla(200, 50%, 40%, 0.75);
		--color-pve-poi-fill: hsla(200, 50%, 40%, 0.5);

		--color-pvp-poi: hsla(69, 44%, 37%, 0.75);
		--color-pvp-poi-fill: hsla(69, 44%, 37%, 0.5);

		--color-selected: hsl(124deg 85.76% 35.18%);
	}

	/* Page Layout */
	h2.pageTitle {
		font-size: 1.25em;
		flex: auto;
		@media (max-width: 1024px) {
			flex: 0 1 100%;
		}
	}

	.overlay-controls {
		position: absolute;
		top: 5.2em;
		right: 1em;
		z-index: 1000;
		display: flex;
		flex-direction: column;
		flex-wrap: wrap;
		align-items: flex-start;
		width: 11em;
		gap: 0.5em;
		padding: 1em 1.5em;
		border-radius: 0.5em;
		background: var(--color-grey-darker);
		box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),
			var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);

		@media (max-width: 1024px) {
			width: 100%;
			position: absolute;
			top: 0;
			right: 0;
			flex-direction: row;
			justify-content: center;
			padding-bottom: 0;
			gap: 0 0.75em;
		}

		label {
			display: flex;
			flex-direction: row;
			gap: 0.5em;
			align-items: center;
		}

		input[type='checkbox'] {
			display: none;
			/* zoom: 1.5;
			@media (max-width: 1024px) {
				zoom: 1;
			} */
		}

		label:has(input[type='checkbox']:checked),
		input[type='checkbox']:checked ~ label {
			color: var(--color-selected);
		}
	}

	/* Form Controls */

	.vehicle-container,
	.modifiers-container {
		display: flex;
		flex-direction: column;
		gap: 0.5em;
		align-items: start;
		justify-content: center;
		flex-wrap: wrap;
		flex-grow: 1;
		background: var(--color-grey-darker);
		&:hover,
		&:has(#vehicles-toggle:checked),
		&:has(#modifiers-toggle:checked) {
			outline: 1px solid #f9f9f963;
			outline-offset: 0.25em;
			border-radius: 0.125em;
		}
	}

	#vehicles-toggle,
	#modifiers-toggle {
		display: none;
	}

	#vehicles-toggle:checked,
	#modifiers-toggle:checked {
		~ label .close {
			display: inline;
		}
		~ label .open {
			display: none;
		}
	}
	#vehicles-toggle:not(:checked),
	#modifiers-toggle:not(:checked) {
		~ label .close {
			display: none;
		}
		~ label .open {
			display: inline;
		}
	}

	#vehicles-toggle:not(:checked) ~ .vehicle-types,
	#modifiers-toggle:not(:checked) ~ .loot-modifiers {
		display: none;
	}

	#vehicles-toggle:checked ~ .vehicle-types,
	#modifiers-toggle:checked ~ .loot-modifiers {
		display: flex;
	}

	.vehicle-types,
	.loot-modifiers {
		flex-direction: column;
		gap: 0.5em;
		align-items: start;
		background: var(--color-grey-darker);
	}

	/* Map Container */
	.map-container {
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100%;
		overflow: hidden;
	}

	.map {
		scale: 1;

		image {
			translate: 60px 45px;
			scale: 0.91;
		}
	}

	/* Base Zone Styles */
	.zone-rect {
		fill: var(--color-zone-default-fill);
		stroke: var(--color-zone-default-fill);
		stroke-width: 1;

		&:hover {
			fill: var(--color-zone-default-hover);
		}
	}

	[class^='zone-Sector_'] text {
		fill: var(--color-white-40);
		font-size: 1em;
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
		text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
		translate: -75px -75px;
	}

	.zone-label,
	[class^='zone-PVP_Bunker'] text,
	[class^='zone-PVE_Bunker'] text,
	[class^='zone-POI_PVE'] text,
	[class^='zone-POI_PVP'] text,
	[class^='zone-POI_custom_'] text,
	[class^='zone-Bunkers_PVE'] text,
	[class^='zone-Bunkers_PVP'] text,
	.zone-Outpost_A0 text,
	[class^='zone-Outpost_'] text,
	.zone-WarZoneDrops text,
	.zone-CommunityCenter text {
		fill: var(--color-white);
		font-size: 0.3em;
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
		font-weight: 300;
		letter-spacing: 0.1em;
		text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
	}

	/* Zone Type Specific Styles */
	.zone-PVE .zone-rect {
		fill: var(--color-pve-fill);
		stroke: var(--color-pve);
		stroke-width: 1;
		&:hover {
			fill: var(--color-pve-hover);
		}
	}

	.zone-PVP .zone-rect {
		fill: var(--color-pvp-fill);
		stroke: var(--color-pvp);
		stroke-width: 1;
	}

	.zone-WarZoneDrops .zone-rect {
		fill: var(--color-warzone-fill);
		stroke: var(--color-warzone);
		stroke-width: 0;
	}

	.zone-CommunityCenter .zone-rect {
		fill: var(--color-community-fill);
		stroke: var(--color-community);
		stroke-width: 0.5;
	}

	/* Sector Styles */
	[class^='zone-Sector_'] {
		.zone-rect {
			stroke: var(--color-white-10);
			stroke-width: 1;
			cursor: pointer;
		}
	}

	/* POI and Outpost Styles */
	[class^='zone-Outpost_'] .zone-circ,
	[class^='zone-POI_custom_'] .zone-circ {
		fill: var(--color-custom-poi-fill);
		stroke: var(--color-custom-poi);
		stroke-width: 0.5;
	}
	[class^='zone-PVE_Bunker'] .zone-circ,
	[class^='zone-POI_PVE'] .zone-rect,
	[class^='zone-POI_PVE'] .zone-circ,
	[class^='zone-Bunkers_PVE'] .zone-rect,
	[class^='zone-Bunkers_PVE'] .zone-circ {
		fill: var(--color-pve-poi-fill);
		stroke: var(--color-pve-poi);
		stroke-width: 0.5;
	}

	[class^='zone-PVP_Bunker'] .zone-circ,
	[class^='zone-POI_PVP'] .zone-rect,
	[class^='zone-POI_PVP'] .zone-circ,
	.zone-Outpost_A0 .zone-rect,
	.zone-Outpost_A0 .zone-circ,
	[class^='zone-Bunkers_PVP'] .zone-rect,
	[class^='zone-Bunkers_PVP'] .zone-circ {
		fill: var(--color-pvp-poi-fill);
		stroke: var(--color-pvp-poi);
		stroke-width: 0.5;
	}

	/* Player Marker Styles */
	.player-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.player-marker circle {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: red;
		stroke: white;
		stroke-width: 0.5;
	}

	/* Vehicle Marker Styles */
	.vehicle-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
		.not-registered {
			fill: red;
		}
	}

	.vehicle-marker .vehicle-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: blue;
		stroke: white;
		stroke-width: 0.5;
	}
	.vehicle-marker.not-registered .vehicle-icon {
		stroke: red;
	}

	/* Event Marker Styles */
	.event-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.5em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.event-marker .event-zone {
		fill: hsla(60, 100%, 50%, 0.2);
		stroke: hsl(60, 100%, 50%);
		stroke-width: 2;
		stroke-dasharray: 10 5;
	}

	/* Kill Marker Styles */
	.kill-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.25em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.kill-marker .kill-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		stroke: white;
		stroke-width: 0.25;
	}

	.kill-marker.killer .kill-icon {
		fill: red;
	}

	.kill-marker.victim .kill-icon {
		fill: black;
	}

	.kill-marker.suicide .kill-icon {
		fill: purple;
	}

	.kill-line {
		stroke: red;
		stroke-width: 0.25;
		stroke-dasharray: 5, 5;
		opacity: 0.5;
	}

	/* Flag Marker Styles */
	.flag-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.flag-marker .flag-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: orange;
		stroke: white;
		stroke-width: 0.5;
	}
</style>
