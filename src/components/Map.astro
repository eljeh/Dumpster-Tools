---
import zones from '../data/zones.json';
import settingZones from '../data/settingZones.json';
import MapControls from './MapControls.astro';
import DataControls from './dataControls.astro';
import LootManager from './lootfiles.astro';
// Find the min and max coordinates to set up the viewport
let minX = Infinity;
let maxX = -Infinity;
let minY = Infinity;
let maxY = -Infinity;

Object.entries(zones).forEach(([_, zoneArray]) => {
	zoneArray.forEach((zone) => {
		if (!zone.TopLeft || !zone.BottomRight) return;
		const topLeft = {
			x: parseFloat(zone.TopLeft.split(' ')[0].replace('X=', '')),
			y: parseFloat(zone.TopLeft.split(' ')[1].replace('Y=', '')),
		};
		const bottomRight = {
			x: parseFloat(zone.BottomRight.split(' ')[0].replace('X=', '')),
			y: parseFloat(zone.BottomRight.split(' ')[1].replace('Y=', '')),
		};
		minX = Math.min(minX, topLeft.x, bottomRight.x);
		maxX = Math.max(maxX, topLeft.x, bottomRight.x);
		minY = Math.min(minY, topLeft.y, bottomRight.y);
		maxY = Math.max(maxY, topLeft.y, bottomRight.y);
	});
});

// Add some padding
const padding = (maxX - minX) * 0.05;
minX -= padding;
maxX += padding;
minY -= padding;
maxY += padding;

// Function to convert game coordinates to SVG coordinates
const toSvgX = (x: number) => ((x - minX) / (maxX - minX)) * 1000;
const toSvgY = (y: number) => 1000 - ((y - minY) / (maxY - minY)) * 1000; // Flip Y axis

const ZONE_NAME_MAPPINGS = {
	Sector_: (name: string) => name.replace('Sector_', ''),
	// MapZones: (name: string) => name,
	POI_PVP: (name: string) => name.replace('POI_PVP', 'PvP '),
	POI_PVE: (name: string) => name.replace('POI_PVE', 'PvE '),
	Bunkers_PVP: (name: string) => name.replace('Bunkers_PVP', 'PvP Bunker'),
	Bunkers_PVE: (name: string) => name.replace('Bunkers_PVE', 'PvE Bunker'),
	// Outpost_: (name: string) => `${name.replace('Outpost_', '')} Outpost`,
	WarZoneDrops: (name: string) => name.replace('WarZoneDrops', 'Warzone Drop'),
} as const;

const formatZoneName = (zoneName: string): string => {
	const prefix = Object.keys(ZONE_NAME_MAPPINGS).find((key) =>
		zoneName.startsWith(key),
	);
	return prefix ? ZONE_NAME_MAPPINGS[prefix](zoneName) : zoneName;
};
---

<div class='wrapper'>
	<div
		class='map-container'
		data-min-x={minX}
		data-max-x={maxX}
		data-min-y={minY}
		data-max-y={maxY}
	>
		<div class='map-controls'>
			<label>
				<input type='checkbox' checked id='sectors-toggle' />
				<i class='fi fi-ss-draw-square'></i>
				<span class='labelText'>Sectors</span>
			</label>

			<label>
				<input type='checkbox' checked id='image-toggle' />
				<i class='fi fi-ss-picture'></i>
				<span class='labelText'>Image</span>
			</label>
		</div>

		<svg viewBox='210 30 930 930' class='map'>
			<image
				href='../assets/images/map.png'
				width='1000'
				height='1000'
				x='169'
				y='0'
			/>
			{
				Object.entries(zones).map(([zoneName, zoneArray]) =>
					zoneArray.map((zone) => {
						if (!zone.TopLeft || !zone.BottomRight) return null;

						const topLeft = {
							x: parseFloat(zone.TopLeft.split(' ')[0].replace('X=', '')),
							y: parseFloat(zone.TopLeft.split(' ')[1].replace('Y=', '')),
						};

						const bottomRight = {
							x: parseFloat(zone.BottomRight.split(' ')[0].replace('X=', '')),
							y: parseFloat(zone.BottomRight.split(' ')[1].replace('Y=', '')),
						};

						const width = Math.abs(toSvgX(topLeft.x) - toSvgX(bottomRight.x));
						const height = Math.abs(toSvgY(topLeft.y) - toSvgY(bottomRight.y));

						// flip left to right all the coordinates
						topLeft.x = -topLeft.x;
						bottomRight.x = -bottomRight.x;

						// if zoneName starts with Sector_, add zone-Sector_ to the class
						const sector = formatZoneName(zoneName);

						return (
							<g
								class={`zone-${zoneName} ${zoneName === 'MapZones' ? `zone-${zone.Name.replace(' ', '')}` : ''}`}
								style={
									zoneName.includes('Sector_') || zoneName === 'MapZones'
										? 'display: block;'
										: 'display: none;'
								}>
								<title>
									{`${zoneName === 'MapZones' ? zone.Name : sector}\nTop Left: (${topLeft.x.toFixed(2)}, ${topLeft.y.toFixed(2)})\nBottom Right: (${bottomRight.x.toFixed(2)}, ${bottomRight.y.toFixed(2)})`}
								</title>
								<rect
									x={toSvgX(Math.min(topLeft.x, bottomRight.x))}
									y={toSvgY(Math.max(topLeft.y, bottomRight.y))}
									width={width}
									height={height}
									class='zone-rect'
								/>
								<text
									x={toSvgX(Math.min(topLeft.x, bottomRight.x)) + width / 2}
									y={toSvgY(Math.max(topLeft.y, bottomRight.y)) + height / 2}
									class='zone-label'>
									{!zoneName.startsWith('Sector_') ? zone.Name : sector}
								</text>
							</g>
						);
					}),
				)
			}
			{
				Object.entries(settingZones).map(([zoneName, zoneArray]) =>
					zoneArray.map((zone) => {
						if (!zone.Center) return null;

						const center = {
							x: -parseFloat(zone.Center.split(' ')[0]), // Flip X coordinate
							y: parseFloat(zone.Center.split(' ')[1]),
						};

						// Handle both circular and rectangular zones
						const isCircular = zone.Radius !== undefined;
						let width, height, radius;

						if (isCircular) {
							radius = parseFloat(zone.Radius) * 100000;
						} else if (zone.size) {
							const [sizeX, sizeY] = zone.size
								.split(' ')
								.map((s) => parseFloat(s) * 100000);
							width = sizeX;
							height = sizeY;
						} else {
							return null;
						}

						const sector = formatZoneName(zoneName);

						return (
							<g
								class={`zone-${zoneName}`}
								style={
									zoneName.includes('Sector_')
										? 'display: block;'
										: 'display: none;'
								}>
								<title>
									{isCircular
										? `${sector}\nCenter: (${center.x.toFixed(2)}, ${center.y.toFixed(2)})\nRadius: ${zone.Radius}`
										: `${sector}\nCenter: (${center.x.toFixed(2)}, ${center.y.toFixed(2)})\nSize: ${zone.size}`}
								</title>

								{isCircular ? (
									<circle
										cx={toSvgX(center.x)}
										cy={toSvgY(center.y)}
										r={(radius / (maxX - minX)) * 1000}
										class='zone-circ'
									/>
								) : (
									<rect
										x={toSvgX(center.x - width)}
										y={toSvgY(center.y + height)}
										width={(width / (maxX - minX)) * 2000}
										height={(height / (maxY - minY)) * 2000}
										class='zone-rect'
									/>
								)}
								<text
									x={toSvgX(center.x)}
									y={toSvgY(center.y)}
									class='zone-label'>
									{sector
										.replace('Custom_', '')
										.replace('PvP', '')
										.replace('PvE', '')
										.replace('PVP_', '')
										.replace('PVE_', '')}
								</text>
							</g>
						);
					}),
				)
			}
		</svg>
	</div>
</div>

<div class='data-table-wrapper' transition:name='wrapper'>
	<DataControls />
	<div class='update-progress'>
		<div class='progress-bar'>
			<div class='progress-fill'></div>
		</div>
		<div class='progress-text'>
			Next update in: <span class='countdown'>3:00</span>
		</div>
	</div>
	<div id='data-table' class='data-table-container'></div>
</div>

<!-- <div id='details-container' class='details-container'>
	<LootManager />
</div> -->

<script>
	import zones from '../data/zones.json';
	import { displayFlagLocations } from '../utils/flagLocations';
	import { displayCurrentEvents } from '../utils/eventsLocations';
	import { displayKillPositions } from '../utils/killLocations';
	import { displayPlayerLocations } from '../utils/playerLocations';
	import { displayVehicleLocations } from '../utils/vehicleLocations';
	import { displayLootLocations } from '../utils/lootLocations';
	import { updateDataWithDiff, clearDataCache } from '../utils/dataUpdate';

	import {
		PUBLIC_WBAUTH,
		PUBLIC_WBBOTID,
		PUBLIC_ROOT,
		PUBLIC_FTP_HOST,
		PUBLIC_FTP_USER,
		PUBLIC_FTP_PASS,
	} from 'astro:env/client';
	const WBAuth = PUBLIC_WBAUTH;
	const WBBotID = PUBLIC_WBBOTID;
	const Root = PUBLIC_ROOT;
	const FTPHost = PUBLIC_FTP_HOST;
	const FTPUser = PUBLIC_FTP_USER;
	const FTPPass = PUBLIC_FTP_PASS;

	// Add this at the top of your script to declare the global type
	declare global {
		interface Window {
			countdownTimer: number;
		}
	}

	document.addEventListener('astro:page-load', () => {
		const mapContainer = document.querySelector(
			'.map-container',
		) as HTMLElement;
		const minX = parseFloat(mapContainer.dataset.minX!);
		const maxX = parseFloat(mapContainer.dataset.maxX!);
		const minY = parseFloat(mapContainer.dataset.minY!);
		const maxY = parseFloat(mapContainer.dataset.maxY!);

		const toSvgX = (x) => ((x - minX) / (maxX - minX)) * 1000;
		const toSvgY = (y) => 1000 - ((y - minY) / (maxY - minY)) * 1000;

		// Get all toggle checkboxes
		const sectorsToggle = document.getElementById(
			'sectors-toggle',
		) as HTMLInputElement;
		const playersToggle = document.getElementById(
			'players-toggle',
		) as HTMLInputElement;
		const vehicleToggle = document.getElementById(
			'vehicles-toggle',
		) as HTMLInputElement;
		const registeredVehiclesToggle = document.getElementById(
			'registered-vehicles-toggle',
		) as HTMLInputElement;
		const notRegisteredVehiclesToggle = document.getElementById(
			'not-registered-vehicles-toggle',
		) as HTMLInputElement;
		const flagsToggle = document.getElementById(
			'flags-toggle',
		) as HTMLInputElement;
		const eventsToggle = document.getElementById(
			'events-toggle',
		) as HTMLInputElement;
		const modifiersToggle = document.getElementById(
			'modifiers-toggle',
		) as HTMLInputElement;
		const killsToggle = document.getElementById(
			'kills-toggle',
		) as HTMLInputElement;
		const ragerToggle = document.getElementById(
			'rager-toggle',
		) as HTMLInputElement;
		const wolfswagenToggle = document.getElementById(
			'wolfswagen-toggle',
		) as HTMLInputElement;
		const laikaToggle = document.getElementById(
			'laika-toggle',
		) as HTMLInputElement;
		const kingletdusterToggle = document.getElementById(
			'kingletduster-toggle',
		) as HTMLInputElement;
		const barbaToggle = document.getElementById(
			'barba-toggle',
		) as HTMLInputElement;
		const risToggle = document.getElementById('ris-toggle') as HTMLInputElement;
		const dirtbikeToggle = document.getElementById(
			'dirtbike-toggle',
		) as HTMLInputElement;
		const cruiserToggle = document.getElementById(
			'cruiser-toggle',
		) as HTMLInputElement;
		const bicyclesToggle = document.getElementById(
			'bicycles-toggle',
		) as HTMLInputElement;
		const wheelbarrowToggle = document.getElementById(
			'wheelbarrow-toggle',
		) as HTMLInputElement;
		const mapZonesToggle = document.getElementById(
			'mapZones-toggle',
		) as HTMLInputElement;
		const pveBunkerToggle = document.getElementById(
			'pve-bunker-toggle',
		) as HTMLInputElement;
		const pvpBunkerToggle = document.getElementById(
			'pvp-bunker-toggle',
		) as HTMLInputElement;
		const warzonesToggle = document.getElementById(
			'warzones-toggle',
		) as HTMLInputElement;
		const outpostsToggle = document.getElementById(
			'outposts-toggle',
		) as HTMLInputElement;
		const serverzonesToggle = document.getElementById(
			'serverzones-toggle',
		) as HTMLInputElement;
		const bunkersToggle = document.getElementById(
			'bunkers-toggle',
		) as HTMLInputElement;
		const imageToggle = document.getElementById(
			'image-toggle',
		) as HTMLInputElement;
		const pois_pvpToggle = document.getElementById(
			'pois-pvp-toggle',
		) as HTMLInputElement;
		const pois_pveToggle = document.getElementById(
			'pois-pve-toggle',
		) as HTMLInputElement;
		const pvpzonesToggle = document.getElementById(
			'pvpzones-toggle',
		) as HTMLInputElement;

		// Function to clear all markers and data
		function clearAllMarkersAndData() {
			const dataTable = document.querySelector('#data-table');
			const playerDataTable = document.querySelector('.player-data-table');
			const vehicleDataTable = document.querySelector('.vehicle-data-table');
			const flagDataTable = document.querySelector('.flag-data-table');
			const killDataTable = document.querySelector('.kill-data-table');
			const eventDataTable = document.querySelector('.event-data-table');

			// Clear all data tables
			if (dataTable) {
				dataTable.innerHTML = '';
			}

			// Uncheck all other toggles
			[
				playersToggle,
				vehicleToggle,
				flagsToggle,
				killsToggle,
				eventsToggle,
			].forEach((toggle) => {
				if (toggle && toggle !== event.target) {
					toggle.checked = false;
				}
			});
		}

		// Function to show progress bar and start countdown
		function showProgress() {
			const progress = document.querySelector(
				'.update-progress',
			) as HTMLElement;
			const progressFill = document.querySelector(
				'.progress-fill',
			) as HTMLElement;
			const countdown = document.querySelector('.countdown') as HTMLElement;

			// Clear any existing countdown
			if (window.countdownTimer) {
				clearTimeout(window.countdownTimer);
			}

			progress.style.display = 'flex';
			progressFill.style.width = '0%';

			// Start countdown from 3 minutes
			let timeLeft = 180; // 3 minutes in seconds
			const updateCountdown = () => {
				const minutes = Math.floor(timeLeft / 60);
				const seconds = timeLeft % 60;
				countdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

				// Update progress bar
				const progress = ((180 - timeLeft) / 180) * 100;
				progressFill.style.width = `${progress}%`;

				if (timeLeft > 0) {
					timeLeft--;
					window.countdownTimer = setTimeout(updateCountdown, 1000);
				}
			};

			updateCountdown();
		}

		// Function to hide progress bar
		function hideProgress() {
			const progress = document.querySelector(
				'.update-progress',
			) as HTMLElement;
			const progressFill = document.querySelector(
				'.progress-fill',
			) as HTMLElement;
			const countdown = document.querySelector('.countdown') as HTMLElement;

			// Clear any existing countdown
			if (window.countdownTimer) {
				clearTimeout(window.countdownTimer);
			}

			progressFill.style.width = '100%';
			countdown.textContent = '0:00';
			setTimeout(() => {
				progress.style.display = 'none';
			}, 300);
		}

		// Update player toggle event listener
		playersToggle.addEventListener('change', (event) => {
			if (playersToggle.checked) {
				clearAllMarkersAndData();
				playersToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				displayPlayerLocations(toSvgX, toSvgY);
				dataTable.style.display = 'block';
				showProgress();
				setInterval(() => {
					if (playersToggle.checked) {
						showProgress();
						fetch(`https://api.whalleybot.com/bot/${WBBotID}/PlayerLocations`, {
							method: 'GET',
							headers: {
								Accept: '*/*',
								Authorization: WBAuth,
							},
						})
							.then((response) => response.json())
							.then((data) => {
								updateDataWithDiff('players', data, (diffData) => {
									document.querySelector('.player-data-table')?.remove();
									displayPlayerLocations(toSvgX, toSvgY);
									hideProgress();
								});
							})
							.catch(() => {
								hideProgress();
							});
					}
				}, 300000);
			} else {
				document.querySelector('.player-markers-container')?.remove();
				document.querySelector('.player-data-table')?.remove();
				clearDataCache('players');
				hideProgress();
			}
		});

		// Update vehicle toggle event listener
		vehicleToggle.addEventListener('change', (event) => {
			if (vehicleToggle.checked) {
				clearAllMarkersAndData();
				vehicleToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				displayVehicleLocations(toSvgX, toSvgY);
				dataTable.style.display = 'block';
				showProgress();
				setInterval(() => {
					if (vehicleToggle.checked) {
						showProgress();
						fetch(
							`https://api.whalleybot.com/bot/${WBBotID}/VehicleLocations`,
							{
								method: 'GET',
								headers: {
									Accept: '*/*',
									Authorization: WBAuth,
								},
							},
						)
							.then((response) => response.json())
							.then((data) => {
								updateDataWithDiff('vehicles', data, (diffData) => {
									document.querySelector('.vehicle-data-table')?.remove();
									displayVehicleLocations(toSvgX, toSvgY);
									hideProgress();
								});
							})
							.catch(() => {
								hideProgress();
							});
					}
				}, 300000);
			} else {
				document.querySelector('.vehicle-markers-container')?.remove();
				document.querySelector('.vehicle-data-table')?.remove();
				clearDataCache('vehicles');
				hideProgress();
			}
		});

		// Update flag toggle event listener
		flagsToggle.addEventListener('change', (event) => {
			if (flagsToggle.checked) {
				clearAllMarkersAndData();
				flagsToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				displayFlagLocations(toSvgX, toSvgY);
				dataTable.style.display = 'block';
				showProgress();
				setInterval(() => {
					if (flagsToggle.checked) {
						showProgress();
						fetch(`https://api.whalleybot.com/bot/${WBBotID}/FlagLocations`, {
							method: 'GET',
							headers: {
								Accept: '*/*',
								Authorization: WBAuth,
							},
						})
							.then((response) => response.json())
							.then((data) => {
								updateDataWithDiff('flags', data, (diffData) => {
									document.querySelector('.flag-data-table')?.remove();
									displayFlagLocations(toSvgX, toSvgY);
									hideProgress();
								});
							})
							.catch(() => {
								hideProgress();
							});
					}
				}, 300000);
			} else {
				document.querySelector('.flag-markers-container')?.remove();
				document.querySelector('.flag-data-table')?.remove();
				clearDataCache('flags');
				hideProgress();
			}
		});

		// Update kills toggle event listener
		killsToggle.addEventListener('change', (event) => {
			if (killsToggle.checked) {
				clearAllMarkersAndData();
				killsToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				const svg = document.querySelector('.map') as SVGElement;
				displayKillPositions(svg, toSvgX, toSvgY);
				dataTable.style.display = 'block';
				showProgress();
				setInterval(() => {
					if (killsToggle.checked) {
						showProgress();
						fetch(`https://api.whalleybot.com/bot/${WBBotID}/KillLocations`, {
							method: 'GET',
							headers: {
								Accept: '*/*',
								Authorization: WBAuth,
							},
						})
							.then((response) => response.json())
							.then((data) => {
								updateDataWithDiff('kills', data, (diffData) => {
									document.querySelector('.kill-data-table')?.remove();
									displayKillPositions(svg, toSvgX, toSvgY);
									hideProgress();
								});
							})
							.catch(() => {
								hideProgress();
							});
					}
				}, 300000);
			} else {
				document.querySelector('.kill-markers-container')?.remove();
				document.querySelector('.kill-data-table')?.remove();
				clearDataCache('kills');
				hideProgress();
			}
		});

		// Update events toggle event listener
		eventsToggle.addEventListener('change', (event) => {
			if (eventsToggle.checked) {
				clearAllMarkersAndData();
				eventsToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				displayCurrentEvents(toSvgX, toSvgY);
				dataTable.style.display = 'block';
				showProgress();
				setInterval(() => {
					if (eventsToggle.checked) {
						showProgress();
						fetch(`https://api.whalleybot.com/bot/${WBBotID}/EventLocations`, {
							method: 'GET',
							headers: {
								Accept: '*/*',
								Authorization: WBAuth,
							},
						})
							.then((response) => response.json())
							.then((data) => {
								updateDataWithDiff('events', data, (diffData) => {
									document.querySelector('.event-data-table')?.remove();
									displayCurrentEvents(toSvgX, toSvgY);
									hideProgress();
								});
							})
							.catch(() => {
								hideProgress();
							});
					}
				}, 300000);
			} else {
				document.querySelector('.event-markers-container')?.remove();
				document.querySelector('.event-data-table')?.remove();
				clearDataCache('events');
				hideProgress();
			}
		});

		modifiersToggle.addEventListener('change', (event) => {
			if (modifiersToggle.checked) {
				clearAllMarkersAndData();
				modifiersToggle.checked = true;
				const dataTable = document.querySelector('#data-table') as HTMLElement;
				displayLootLocations(zones);
				dataTable.style.display = 'block';
				// showProgress();
				setInterval(() => {
					if (modifiersToggle.checked) {
						// showProgress();
						updateDataWithDiff('modifiers', zones, (diffData) => {
							document.querySelector('.modifier-data-table')?.remove();
							displayLootLocations(zones);
							hideProgress();
						});
					}
				}, 300000);
			} else {
				document.querySelector('.modifier-markers-container')?.remove();
				document.querySelector('.modifier-data-table')?.remove();
				clearDataCache('modifiers');
				hideProgress();
			}
		});

		// Function to toggle visibility
		function updateVisibility(toggleElement, selector) {
			if (!toggleElement) return;

			const updateElements = () => {
				const elements = document.querySelectorAll(selector);
				elements.forEach((element) => {
					// Special handling for vehicle markers container
					if (selector === '.vehicle-markers-container') {
						element.style.display = toggleElement.checked ? 'block' : 'none';
						return;
					}

					// For individual vehicle markers, check both the vehicles toggle and registration toggles
					if (selector.includes('.vehicle-marker')) {
						const isVehiclesEnabled = vehicleToggle.checked;
						const isRegistered = element.classList.contains('registered');
						const isRegisteredEnabled = registeredVehiclesToggle.checked;
						const isNotRegisteredEnabled = notRegisteredVehiclesToggle.checked;

						const shouldShow =
							isVehiclesEnabled &&
							((isRegistered && isRegisteredEnabled) ||
								(!isRegistered && isNotRegisteredEnabled));

						element.style.display = shouldShow ? 'block' : 'none';
					} else {
						element.style.display = toggleElement.checked ? 'block' : 'none';
					}
				});
			};

			toggleElement.addEventListener('change', updateElements);
			// Also update initial state
			updateElements();

			// For vehicle-specific toggles, also listen to vehicles toggle changes
			if (selector.includes('.vehicle-marker')) {
				vehicleToggle.addEventListener('change', updateElements);
				if (toggleElement !== registeredVehiclesToggle) {
					registeredVehiclesToggle.addEventListener('change', updateElements);
				}
				if (toggleElement !== notRegisteredVehiclesToggle) {
					notRegisteredVehiclesToggle.addEventListener(
						'change',
						updateElements,
					);
				}
			}
		}

		// Set up toggle handlers
		updateVisibility(sectorsToggle, '[class^="zone-Sector_"]');
		updateVisibility(playersToggle, '.player-markers-container');
		updateVisibility(flagsToggle, '.flag-markers-container');
		updateVisibility(eventsToggle, '.event-markers-container');
		updateVisibility(killsToggle, '.kill-markers-container');
		updateVisibility(vehicleToggle, '.vehicle-markers-container');
		updateVisibility(registeredVehiclesToggle, '.vehicle-marker.registered');
		updateVisibility(
			notRegisteredVehiclesToggle,
			'.vehicle-marker.not-registered',
		);
		updateVisibility(mapZonesToggle, '.zone-MapZones');
		updateVisibility(bunkersToggle, '[class^="zone-PVP_Bunker"]');
		updateVisibility(bunkersToggle, '[class^="zone-PVE_Bunker"]');
		updateVisibility(pveBunkerToggle, '[class^="zone-Bunkers_PVE"]');
		updateVisibility(pvpBunkerToggle, '[class^="zone-Bunkers_PVP"]');
		updateVisibility(warzonesToggle, '.zone-WarZoneDrops');
		updateVisibility(outpostsToggle, '[class^="zone-Outpost_"]');
		updateVisibility(serverzonesToggle, '[class^="zone-Custom_"]');
		updateVisibility(pois_pvpToggle, '[class^="zone-POI_PVP"]');
		updateVisibility(pois_pveToggle, '[class^="zone-POI_PVE"]');
		updateVisibility(pvpzonesToggle, '[class^="zone-PVP-Zone"]');
		updateVisibility(imageToggle, '.map image');
		updateVisibility(ragerToggle, '.Rager, .Rager-row');
		updateVisibility(wolfswagenToggle, '.WolfsWagen, .WolfsWagen-row');
		updateVisibility(laikaToggle, '.Laika, .Laika-row');
		updateVisibility(
			kingletdusterToggle,
			'.Kinglet_Duster, .Kinglet_Duster-row',
		);
		updateVisibility(
			barbaToggle,
			'.Barba, .Barba-row, .BigRaft, .BigRaft-row, .SmallRaft, .SmallRaft-row, .SUP, .SUP-row',
		);
		updateVisibility(risToggle, '.RIS, .RIS-row');
		updateVisibility(dirtbikeToggle, '.Dirtbike, .Dirtbike-row');
		updateVisibility(cruiserToggle, '.Cruiser, .Cruiser-row');
		updateVisibility(
			bicyclesToggle,
			'.MountainBike, .MountainBike-row, .CityBike, .CityBike-row',
		);
		updateVisibility(
			wheelbarrowToggle,
			'.WheelBarrow_Improvised, .WheelBarrow_Improvised-row',
		);
		updateVisibility(
			wheelbarrowToggle,
			'.WheelBarrow_Metal, .WheelBarrow_Metal-row',
		);

		// Add zoom functionality
		const svg = document.querySelector('.map');
		let isZoomed = false;
		let currentZoom = null;
		const defaultViewBox = '210 30 930 930';
		const imageWidth = 930;
		const imageHeight = 930;
		const imageX = 210;
		const imageY = 30;

		// Function to handle zoom
		function zoomToElement(element) {
			if (!svg || !element) return;

			const rect = element.querySelector('.zone-rect');
			if (!rect) return;

			const bbox = rect.getBBox();
			const padding = 20;

			const viewBox = {
				x: bbox.x - padding,
				y: bbox.y - padding,
				width: bbox.width + padding * 2,
				height: bbox.height + padding * 2,
			};

			if (isZoomed && currentZoom === element) {
				svg.setAttribute('viewBox', defaultViewBox);
				isZoomed = false;
				currentZoom = null;
			} else {
				svg.setAttribute(
					'viewBox',
					`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`,
				);
				isZoomed = true;
				currentZoom = element;
			}
		}

		// Add click handlers to sector zones
		document.querySelectorAll('[class^="zone-Sector_"]').forEach((zone) => {
			(zone as HTMLElement).style.cursor = 'pointer';
			zone.addEventListener('click', () => zoomToElement(zone));
		});

		// Add reset zoom on map container double click
		mapContainer.addEventListener('dblclick', (e) => {
			if (e.target === mapContainer || e.target === svg) {
				svg.setAttribute('viewBox', defaultViewBox);
				isZoomed = false;
				currentZoom = null;
			}
		});

		// Add event listeners for toggles
		[
			'mapZones-toggle',
			'pois-pvp-toggle',
			'pois-pve-toggle',
			'pve-bunker-toggle',
			'pvp-bunker-toggle',
			'warzones-toggle',
		].forEach((id) => {
			const toggle = document.getElementById(id);
			toggle?.addEventListener('change', () => {
				console.log(
					`Toggle changed: ${id} is now ${(toggle as HTMLInputElement).checked}`,
				);
				displayLootLocations(zones);
			});
		});
	});
</script>

<style is:inline>
	/* Base Variables */
	:root {
		/* Core colors */
		--color-white: hsl(0, 0%, 100%);
		--color-white-40: hsla(0, 0%, 100%, 0.4);
		--color-white-10: hsla(0, 0%, 100%, 0.1);
		--color-black: hsl(0, 0%, 0%);
		--color-grey-darker: hsla(0, 0%, 13%, 1);
		--color-grey-dark: hsla(0, 0%, 20%, 1);

		/* Zone colors */
		--color-zone: hsla(207, 44%, 49%, 1);
		--color-zone-fill: hsla(207, 44%, 49%, 0.2);
		--color-zone-hover: hsla(207, 44%, 49%, 0.4);

		--color-pve: hsla(121, 100%, 75%, 1);
		--color-pve-fill: hsla(121, 100%, 75%, 0.2);
		--color-pve-hover: hsla(121, 100%, 75%, 0.4);

		--color-pvp: hsla(0, 44%, 49%, 1);
		--color-pvp-fill: hsla(0, 44%, 49%, 0.2);
		--color-pvp-hover: hsla(0, 44%, 49%, 0.4);

		--color-event-poi: hsla(0, 0%, 100%, 1);
		--color-event-poi-fill: hsla(0, 0%, 100%, 0.5);
		--color-event-poi-hover: hsla(0, 0%, 100%, 0.4);

		--color-warzone: hsla(297, 44%, 49%, 1);
		--color-warzone-fill: hsla(297, 44%, 49%, 0.2);

		--color-community: hsla(0, 0%, 67%, 0.75);
		--color-community-fill: hsla(0, 0%, 67%, 0.5);

		--color-kingofthecastle: hsl(38, 100%, 50%);
		--color-kingofthecastle-fill: hsla(38, 100%, 50%, 0.2);

		/* POI colors */
		--color-poi: hsla(147, 41%, 41%, 1);
		--color-poi-fill: hsla(147, 41%, 41%, 0.2);

		--color-pve-poi: hsla(200, 50%, 40%, 1);
		--color-pve-poi-fill: hsla(200, 50%, 40%, 0.2);

		--color-pvp-poi: hsla(69, 44%, 37%, 1);
		--color-pvp-poi-fill: hsla(69, 44%, 37%, 0.2);

		/* Marker colors */
		--color-player: hsla(0, 100%, 50%, 1);
		--color-vehicle: hsla(240, 100%, 50%, 1);
		--color-vehicle-unregistered: hsla(0, 100%, 50%, 1);
		--color-flag: hsla(39, 100%, 50%, 1);
		--color-loot: hsla(120, 100%, 25%, 1);
		--color-kill-killer: hsla(0, 100%, 50%, 1);
		--color-kill-victim: hsla(0, 0%, 0%, 1);
		--color-kill-suicide: hsla(300, 100%, 25%, 1);
		--color-event: hsla(60, 100%, 50%, 1);
		--color-event-fill: hsla(60, 100%, 50%, 0.2);

		/* Shadow */
		--shadow-text: 0 0 8px hsla(0, 0%, 0%, 0.8);
		--shadow-marker: 2px 2px 2px hsla(0, 0%, 0%, 0.5);
	}

	main {
		display: flex;
		min-height: unset;
		gap: 1.5em;
		flex-wrap: wrap;
		font-size: 1em;
		@media (max-width: 1024px) {
			font-size: 0.75em;
		}
	}

	.wrapper {
		max-width: 46vw;
		flex: 1 1 calc(100vh - 4.25em);
		width: unset;
		aspect-ratio: 1/1;
		padding: 0.25em 0.5em 0.25em 0.5em;
	}

	/* Consolidated zone styles */
	/* .zone-rect {
		fill: var(--fill-color, var(--zone--default));
		stroke: var(--stroke-color, var(--zone--default));
		stroke-width: var(--stroke-width, 1);

		&:hover {
			fill: var(--hover-color, var(--zone--default-hover));
		}
	} */

	.zone-rect {
		fill: var(--color-zone-default-fill);
		stroke: var(--color-zone-default-fill);
		stroke-width: 1;

		&:hover {
			fill: var(--color-zone-default-hover);
		}
	}

	/* Consolidated text styles */
	.zone-label {
		fill: var(--color-white);
		font-size: 0.3em;
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
		text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
	}

	/* Marker styles */
	.marker {
		&-text {
			text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
			pointer-events: none;
			text-anchor: middle;
			fill: white;
			font-size: 0.3em;
			letter-spacing: 0.05em;
		}

		&-icon {
			filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
			stroke: white;
			stroke-width: 0.5;
		}
	}

	/* Page Layout */
	h2.pageTitle {
		font-size: 1.25em;
		flex: auto;
		@media (max-width: 1024px) {
			flex: 0 1 100%;
		}
	}

	.data-table-wrapper {
		overflow-y: scroll;
		max-height: calc(100vh - 6.5em);
		flex: 1 1 auto;
		/* flex: 1 1 46em; */
		/* min-width: 30em; */
		padding: 1em 1em;
		border-radius: 0.5em;
		background: var(--color-grey-darker);
		box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000),
			var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
	}

	.data-table-wrapper {
		scrollbar-color: var(--color-primary) var(--color-tertiary);
	}

	.data-table-wrapper::-webkit-scrollbar {
		background: var(--color-primary);
	}
	.data-table-wrapper::-webkit-scrollbar-thumb {
		background: var(--color-tertiary);
	}

	/* Map Container */
	.map-container {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 100%;
		overflow: hidden;
		border-radius: 0.25em;
		position: relative;
	}

	.map-controls {
		display: flex;
		flex-direction: row;
		justify-content: center;
		align-items: center;
		gap: 0.5em;
		position: absolute;
		z-index: 1;
		bottom: 1em;
		right: 1.5em;
		font-size: 0.75em;
		label {
			display: grid;
			grid-template-areas: 'overlap';
			align-items: center;
			input {
				grid-area: overlap;
				zoom: 2;
				opacity: 0;
				cursor: pointer;
			}
			.fi {
				font-size: 1.5em;
				line-height: 0;
				grid-area: overlap;
				cursor: pointer;
				text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
			}
			.labelText {
				font-size: 0;
				grid-area: overlap;
				margin-left: 0.75em;
				transition: font-size 0.5sease -in-out;
				opacity: 0;
			}
		}
	}

	.map {
		scale: 1;

		image {
			translate: 60px 45px;
			scale: 0.91;
		}
	}

	/* Base Zone Styles */
	[class^='zone-Sector_'] text {
		fill: var(--color-white-40);
		font-size: 1em;
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
		text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
		translate: -75px -75px;
	}

	.zone-label,
	[class^='zone-PVP_Bunker'] text,
	[class^='zone-PVE_Bunker'] text,
	[class^='zone-POI_EVENT'] text,
	[class^='zone-POI_PVE'] text,
	[class^='zone-POI_PVP'] text,
	[class^='zone-Custom_'] text,
	[class^='zone-Event_'] text,
	[class^='zone-Bunkers_PVE'] text,
	[class^='zone-Bunkers_PVP'] text,
	.zone-Outpost_Z3 text,
	[class^='zone-Outpost_'] text,
	.zone-WarZoneDrops text,
	.zone-Custom_CommunityCenter text {
		fill: var(--color-white);
		font-size: 0.3em;
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
		font-weight: 300;
		letter-spacing: 0.1em;
		text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
	}

	/* Zone Type Specific Styles */
	.zone-PvEZone .zone-rect {
		fill: var(--color-pve-fill);
		stroke: var(--color-pve);
		stroke-width: 1;
		&:hover {
			fill: var(--color-pve-hover);
		}
	}

	.zone-PvPZone .zone-rect {
		fill: var(--color-pvp-fill);
		stroke: var(--color-pvp);
		stroke-width: 1;
		&:hover {
			fill: var(--color-pvp-hover);
		}
	}



	.zone-PVP-Zone .zone-rect,
	.zone-PVP-Zone .zone-circ {
		fill: var(--color-pvp-fill);
		/* stroke: var(--color-pvp);
		stroke-width: 1; */
	}


	.zone-WarZoneDrops .zone-rect {
		fill: var(--color-warzone-fill);
		stroke: var(--color-warzone);
		stroke-width: 0;
	}

	.zone-Custom_CommunityCenter .zone-rect {
		fill: var(--color-community-fill);
		stroke: var(--color-community);
		stroke-width: 0.5;
	}
	.zone-Custom_KingOfTheCastle .zone-circ {
		fill: var(--color-kingofthecastle-fill);
		stroke: var(--color-kingofthecastle);
		stroke-width: 0.5;
	}

	/* Sector Styles */
	[class^='zone-Sector_'] {
		.zone-rect {
			stroke: var(--color-white-10);
			stroke-width: 1;
			cursor: pointer;
		}
	}

	/* POI and Outpost Styles */
	[class^='zone-Outpost_'] .zone-circ,
	[class^='zone-POI_'] .zone-circ,
	[class^='zone-POI_'] .zone-rect {
		fill: var(--color-poi-fill);
		stroke: var(--color-poi);
		stroke-width: 0.5;
	}

	[class^='zone-Custom_PVE_'] .zone-circ,
	[class^='zone-Custom_PVE_'] .zone-rect,
	[class^='zone-PVE_Bunker'] .zone-circ,
	[class^='zone-Bunkers_PVE'] .zone-rect,
	[class^='zone-Bunkers_PVE'] .zone-circ {
		fill: var(--color-pve-poi-fill);
		stroke: var(--color-pve-poi);
		stroke-width: 0.5;
	}

	[class^='zone-POI_EVENT'] .zone-rect,
	[class^='zone-POI_EVENT'] .zone-circ {
		fill: var(--color-event-poi-fill);
		stroke: var(--color-event-poi);
		stroke-width: 0.5;
	}

	.zone-Outpost_Z3 .zone-rect,
	.zone-Outpost_Z3 .zone-circ,
	[class^='zone-Custom_PVP_'] .zone-circ,
	[class^='zone-Custom_PVP_'] .zone-rect,
	[class^='zone-PVP_Bunker'] .zone-circ,
	[class^='zone-Bunkers_PVP'] .zone-rect,
	[class^='zone-Bunkers_PVP'] .zone-circ {
		fill: var(--color-pvp-poi-fill);
		stroke: var(--color-pvp-poi);
		stroke-width: 0.5;
	}

	/* Player Marker Styles */
	.player-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.player-marker circle {
		filter: drop-shadow(var(--shadow-marker));
		fill: var(--color-player);
		stroke: var(--color-white);
		stroke-width: 0.5;
		transition:
			r 0.2s ease-in-out,
			fill 0.2s ease-in-out;
	}

	.player-marker.highlighted {
		position: relative;
	}

	.player-marker.highlighted circle {
		r: 5;
		fill: var(--color-accent);
		text-shadow: 0px 0px 10px rgb(0, 0, 0);
		stroke-width: 0.75;
		transition: all 0.2s ease-in-out;
	}

	.player-marker.highlighted text {
		font-size: 0.5em;
		fill: var(--color-white);
		text-shadow: 0px 0px 10px rgb(0, 0, 0);
		transition: all 0.2s ease-in-out;
	}

	/* Vehicle Marker Styles */
	.vehicle-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
		.not-registered {
			fill: red;
		}
	}

	.vehicle-marker .vehicle-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: blue;
		stroke: white;
		stroke-width: 0.5;
	}
	.vehicle-marker.not-registered .vehicle-icon {
		stroke: red;
	}

	.vehicle-marker.highlighted {
		position: relative;
	}

	.vehicle-marker.highlighted .vehicle-icon {
		fill: var(--color-accent);
		stroke-width: 0.75;
		r: 5;
		transition: all 0.2s ease-in-out;
	}

	.vehicle-marker.highlighted text {
		font-size: 0.5em;
		fill: var(--color-white);
		text-shadow: 0px 0px 10px rgb(0, 0, 0);
		transition: all 0.2s ease-in-out;
	}

	/* Event Marker Styles */
	.event-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.5em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.event-marker .event-zone {
		fill: hsla(60, 100%, 50%, 0.2);
		stroke: hsl(60, 100%, 50%);
		stroke-width: 1;
		stroke-dasharray: 10 5;
	}

	/* Kill Marker Styles */
	.kill-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.25em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.kill-marker .kill-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		stroke: white;
		stroke-width: 0.25;
	}

	.kill-marker.killer .kill-icon {
		fill: red;
	}

	.kill-marker.victim .kill-icon {
		fill: black;
	}

	.kill-marker.suicide .kill-icon {
		fill: purple;
	}

	.kill-line {
		stroke: red;
		stroke-width: 0.25;
		stroke-dasharray: 5, 5;
		opacity: 0.5;
	}

	/* Flag Marker Styles */
	.flag-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.flag-marker .flag-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: orange;
		stroke: white;
		stroke-width: 0.5;
	}

	/* Loot Marker Styles */
	.loot-marker text {
		text-shadow: 0px 0px 8px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		text-anchor: middle;
		fill: white;
		font-size: 0.3em;
		stroke: none;
		letter-spacing: 0.05em;
	}

	.loot-marker .loot-icon {
		filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
		fill: green;
		stroke: white;
		stroke-width: 0.5;
	}

	input[type='checkbox']:checked + .vehicleList {
		display: block;
	}

	.data-table-container {
		display: block;
		/* margin-top: 1em; */
	}

	.vehicleList li,
	.playerList li,
	.killList li,
	.flagList li,
	.lootList li {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		gap: 0;
		flex-wrap: wrap;
		border-bottom: 0.25em solid var(--color-primary);
		justify-content: flex-start;
		padding: 0 0.5em;
	}

	li.vehicleList-Header,
	li.playerList-Header,
	li.killList-Header,
	li.flagList-Header,
	.lootList-Header {
		background: var(--color-primary);
		border-top-left-radius: 0.5em;
		border-top-right-radius: 0.5em;
		border-bottom: none;
	}

	.vehicleList li:not(:first-child):hover,
	.playerList li:not(:first-child):hover,
	.killList li:not(:first-child):hover,
	.flagList li:not(:first-child):hover,
	.lootList li:not(:first-child):hover {
		background: var(--color-primary);
	}
	.vehicleList li span,
	.vehicleList li a,
	.playerList li span,
	.playerList li a,
	.killList li span,
	.killList li a,
	.flagList li span,
	.flagList li a,
	.lootList li span,
	.lootList li a {
		padding: 0.25em 0.5em;
		border-radius: 0.25em;
	}
	.vehicleList li:not(:first-child) .clickable:hover,
	.vehicleList li:not(:first-child) a:hover,
	.playerList li:not(:first-child) span:hover,
	.playerList li:not(:first-child) a:hover,
	.killList li:not(:first-child) span:hover,
	.killList li:not(:first-child) a:hover,
	.flagList li:not(:first-child) span:hover,
	.flagList li:not(:first-child) a:hover {
		background: var(--color-accent);
		cursor: pointer;
	}

	.vehicleList li.type-header {
		padding: 0;
	}

	.vehicleList li.type-header .type-summary {
		flex: 1;
		background: var(--color-grey-dark);
		font-size: 1.1em;
		font-weight: 600;
		color: #ababab;
		letter-spacing: 0.1em;
		input {
			opacity: 0;
		}
	}

	.data-table-container li .vID {
		flex: 0 1 12ch;
	}
	.data-table-container li .vType {
		flex: 0 1 17ch;
	}
	.data-table-container li .coords {
		flex: 0 1 32ch;
	}
	.data-table-container li .steamID {
		flex: 0 1 20ch;
	}
	.data-table-container li .zoneName {
		flex: 0 1 28ch;
	}
	.data-table-container li .playerName {
		flex: 0 1 24ch;
	}
	.data-table-container li .pType {
		flex: 0 1 10ch;
	}

	.data-table-container li span:last-child {
		flex: 1;
	}

	#VehicleContainer > div {
		margin-bottom: 1em;
	}

	.update-progress {
		position: sticky;
		top: -1em;
		background: var(--color-grey-darker);
		padding: 0.25em 1em;
		display: none;
		align-items: center;
		gap: 1em;
		z-index: 1000;
	}

	.progress-bar {
		width: 100%;
		height: 4px;
		background: var(--color-grey-dark);
		border-radius: 2px;
		overflow: hidden;
	}

	.progress-fill {
		width: 0%;
		height: 100%;
		background: var(--color-accent);
		transition: width 0.3s ease-in-out;
	}

	.progress-text {
		color: var(--color-white);
		font-size: 0.75em;
		white-space: nowrap;
		text-align: right;
		min-width: 16ch;
	}
</style>
